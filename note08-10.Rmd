---
title: "Chapter 8, 9, 10"
output: html_notebook
---

# 8 Function minimization tools in the base R system

## 8.4 Using the base optimization tools

```{r}
fr <- function(x) {
  ## Rosenbrock Banana function
  x1 <- x[1]
  x2 <- x[2]
  100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
sstart <- c(-1.2, 1)
```

```{r}
prtopt <- function(optres, headname) { # compact print of optim() result
  cat(headname, ": f(")
  npar <- length(optres$par)
  for (i in 1:(npar - 1)) {
    cat(optres$par[[i]], ", ")
  }
  cat(optres$par[[npar]], ") = ", optres$value, " after ", optres$counts[[1]], "f & ", optres$counts[[2]], "g\n")
  cat(optres$message, "  convergence code=", optres$convergence, "\n")
  # tmp<-readline("continue")
}
```

```{r}
## ----label=C08roseoptim, echo=TRUE, cache=TRUE---------------------------
anm <- optim(sstart, fr) # Nelder Mead is the default method
anm # prtopt(anm, "anm")
```

```{r}
abfgs <- optim(sstart, fr, method = "BFGS")
abfgs # prtopt(abfgs, "abfgs")
```

```{r}
acg1 <- optim(sstart, fr, method = "CG", control = list(type = 1))
acg1 # prtopt(acg1, "acg1")
```

```{r}
acg2 <- optim(sstart, fr, method = "CG", control = list(type = 2))
acg2 # prtopt(acg2, "acg2")
```

```{r}
acg3 <- optim(sstart, fr, method = "CG", control = list(type = 3))
acg3 # prtopt(acg3, "acg3")
```

```{r}
albfgsb <- optim(sstart, fr, method = "L-BFGS-B")
albfgsb # prtopt(albfgsb, "albfgsb")
```

```{r}
frg <- function(x) { ## Rosenbrock Banana function gradient
  x1 <- x[1]
  x2 <- x[2]
  g1 <- -400 * (x2 - x1 * x1) * x1 - 2 * (1 - x1)
  g2 <- 200 * (x2 - x1 * x1)
  gg <- c(g1, g2)
}
```

```{r}
require(numDeriv)
gn <- grad(fr, sstart)
gn
```

```{r}
ga <- frg(sstart)
## max(abs(ga-gn))
max(abs(ga - gn))
## analytic gradient results
```

```{r}
gabfgs <- optim(sstart, fr, frg, method = "BFGS")
gabfgs # prtopt(gabfgs,"BFGS w. frg")
```

```{r}
gacg1 <- optim(sstart, fr, frg, method = "CG", control = list(type = 1))
gacg1 # prtopt(gacg1,"CG Fletcher-Reeves w. frg")
```

```{r}
gacg2 <- optim(sstart, fr, frg, method = "CG", control = list(type = 2))
gacg2 # prtopt(gacg2,"CG Polak-Ribiere w. frg")
```

```{r}
gacg3 <- optim(sstart, fr, frg, method = "CG", control = list(type = 3))
gacg3 # prtopt(gacg3,"CG Beale-Sorenson w. frg")
```

```{r}
galbfgsb <- optim(sstart, fr, method = "L-BFGS-B")
galbfgsb # prtopt(galbfgsb,"L-BFGS-B w. frg")
```

# 9 Add-in function minimization packages for R

## 9.1 Package optimx

### 9.1.2 Example use of optimx()

```{r}
## ----label=C09rb, echo=TRUE----------------------------------------------
require(optimx)
fr <- function(x) { ## Rosenbrock Banana function
  x1 <- x[1]
  x2 <- x[2]
  100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
frg <- function(x) { ## Rosenbrock Banana function gradient
  x1 <- x[1]
  x2 <- x[2]
  g1 <- -400 * (x2 - x1 * x1) * x1 - 2 * (1 - x1)
  g2 <- 200 * (x2 - x1 * x1)
  gg <- c(g1, g2)
}
sstart <- c(-1.2, 1)
arb <- optimx(par = sstart, fn = fr, gr = frg, control = list(all.methods = TRUE))
print(summary(arb, order = value))
```

```{r}
# install.packages("nloptr")
require(nloptr)
```

```{r}
nowp <- function(answer) {
  # nloptwrap answer summary
  cat("Fn =", answer$value, " after ", answer$iter, " iterations, parameters:\n")
  print(answer$par)
  cat(answer$message, "\n")
  invisible(0)
}


albfgs <- lbfgs(sstart, fr, gr = frg)
albfgs # nowp(albfgs)
```

```{r}
atnewton <- tnewton(sstart, fr, gr = frg)
atnewton # nowp(atnewton)
```

```{r}
avarmetric <- varmetric(sstart, fr, gr = frg)
avarmetric # nowp(avarmetric)
```

```{r}
anelmead <- neldermead(sstart, fr)
anelmead # nowp(anelmead)
```

```{r}
anelmead <- neldermead(sstart, fr)
anelmead # nowp(anelmead)
```

```{r}
anewuoa <- newuoa(sstart, fr)
anewuoa # nowp(anewuoa)
```

### 9.2.2 trust and trustOptim

```{r}
## ----label=C09rbtrust, echo=TRUE, cache=TRUE-----------------------------
frh <- function(x) { ## Rosenbrock Banana function gradient
  x1 <- x[1]
  x2 <- x[2]
  h11 <- -400 * x2 + 1200 * x1 * x1 + 2
  h12 <- -400 * x1
  h21 <- h12
  h22 <- 200
  HH <- matrix(c(h11, h12, h21, h22), nrow = 2, ncol = 2)
}
objfun1 <- function(x) {
  val <- fr(x)
  gg <- frg(x)
  HH <- frh(x)
  list(value = val, gradient = gg, hessian = HH)
}
objfun2 <- function(x) {
  stopifnot(is.numeric(x))
  stopifnot(length(x) == 2)
  f <- expression(100 * (x2 - x1^2)^2 + (1 - x1)^2)
  g1 <- D(f, "x1")
  g2 <- D(f, "x2")
  h11 <- D(g1, "x1")
  h12 <- D(g1, "x2")
  h22 <- D(g2, "x2")
  x1 <- x[1]
  x2 <- x[2]
  f <- eval(f)
  g <- c(eval(g1), eval(g2))
  B <- rbind(c(eval(h11), eval(h12)), c(eval(h12), eval(h22)))
  list(value = f, gradient = g, hessian = B)
}
require(trust)
atrust1 <- trust(objfun1, sstart, rinit = 1, rmax = 5)
atrust1
## Get same answers from
## atrust2<-trust(objfun2, sstart, rinit=1, rmax=5)
```

# 10 Calculating and using derivatives

## 10.4 Examples of use of R tools for differentiation

```{r}
mod <- ~ 100 * b1 / (1 + 10 * b2 * exp(-0.1 * b3 * t))
mod
```

```{r}
namev <- c("b1", "b2", "b3")
try1 <- deriv(mod, namev)
try1
```

```{r}
resfn <- function(pars, t = t, y = y) {
  b1 <- pars[[1]]
  b2 <- pars[[2]]
  b3 <- pars[[3]]
  .expr1 <- 100 * b1
  .expr2 <- 10 * b2
  .expr6 <- exp(-0.1 * b3 * t)
  .expr8 <- 1 + .expr2 * .expr6
  .expr13 <- .expr8^2
  .value <- .expr1 / .expr8
  .grad <- array(0, c(length(.value), 3L), list(NULL, c(
    "b1",
    "b2", "b3"
  )))
  .grad[, "b1"] <- 100 / .expr8
  .grad[, "b2"] <- -(.expr1 * (10 * .expr6) / .expr13)
  .grad[, "b3"] <- .expr1 * (.expr2 * (.expr6 * (0.1 * t))) / .expr13
  attr(.value, "gradient") <- .grad
  .value
  res <- .value - y
  attr(res, "jacobian") <- .grad
  res
}
```

```{r}
## Test the function
ydat <- c(
  5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443,
  38.558, 50.156, 62.948, 75.995, 91.972
) # for testing
tdat <- 1:length(ydat) # for testing
start <- c(1, 1, 1)
myres <- resfn(start, y = ydat, t = tdat)
# myres
print(as.vector(myres)) # we don't want the "gradient"
```

```{r}
ss <- as.numeric(crossprod(as.vector(myres)))
ss
```

```{r}
JJ <- attr(myres, "jacobian")
JJ
```

```{r}
svd(JJ)$d
```

```{r}
grad <- crossprod(JJ, as.vector(myres))
print(as.vector(grad))
```

## 10.6 Improved numerical derivative approximations

### 10.6.2 Complex-step derivative approximations

```{r}

if ("package:pracma" %in% search()) {
  detach(package:pracma) # avoid confusion between two grad() functions
}
f1 <- function(x) 1 + x^2
f2 <- function(x) abs(1 + x^2)
numDeriv::grad(f1, 1, method = "complex")
```

```{r}
try(numDeriv::grad(f2, 1, method = "complex"))
```

## 10.7 Strategy and tactics for derivatives

```{r}
genrose.f <- function(x, gs = 100) {
  # objective function
  # A generalization of the Rosenbrock banana valley function to n parameters
  n <- length(x)
  fval <- 1.0 + sum(gs * (x[1:(n - 1)]^2 - x[2:n])^2 + (x[2:n] - 1)^2)
  return(fval)
}

genrose.g <- function(x, gs = 100) {
  # vectorized gradient for genrose.f
  n <- length(x)
  gg <- as.vector(rep(0, n))
  tn <- 2:n
  tn1 <- tn - 1
  z1 <- x[tn] - x[tn1]^2
  z2 <- 1 - x[tn]
  gg[tn] <- 2 * (gs * z1 - z2)
  gg[tn1] <- gg[tn1] - 4 * gs * x[tn1] * z1
  return(gg)
}

p <- function(fn, xx, epstol = 1.e-07, ...) {
  # Simple forward approx using 1E-7 tol (scaled)
  ## 	epstol <- 1.0E-7
  f0 <- fn(xx, ...)
  ll <- length(xx)
  gg <- rep(NA, ll)
  for (ii in 1:ll) {
    xt <- xx
    delta <- epstol * (abs(xt[ii]) + epstol)
    xt[ii] <- xx[ii] + delta
    ft <- fn(xt, ...)
    gg[ii] <- (ft - f0) / delta
  }
  gg
}

centgapp <- function(fn, xx, epstol = 1.e-07, ...) {
  # Simple central approx using 1E-7 tol (scaled)
  ## 	epstol <- 1.0E-7
  f0 <- fn(xx, ...)
  ll <- length(xx)
  gg <- rep(NA, ll)
  for (ii in 1:ll) {
    xt <- xx
    delta <- epstol * (abs(xt[ii]) + epstol)
    xt[ii] <- xx[ii] + delta
    ff <- fn(xt, ...)
    xt[ii] <- xx[ii] - delta
    fb <- fn(xt, ...)
    gg[ii] <- 0.5 * (ff - fb) / delta
  }
  gg
}

##################

vnorm <- function(x) {
  sqrt(mean(x^2))
}
dummy <- function(x) {
  y <- 1
}
```

```{r}
# run the tests

require(numDeriv)

maxn <- 10
n <- rep(NA, maxn)
ag <- rep(NA, maxn)
atym <- rep(NA, maxn)
ntym <- rep(NA, maxn)
ftym <- rep(NA, maxn)
xtym <- rep(NA, maxn)
ctym <- rep(NA, maxn)
nrat <- rep(NA, maxn)
frat <- rep(NA, maxn)
xrat <- rep(NA, maxn)
crat <- rep(NA, maxn)
nabs <- rep(NA, maxn)
fabs <- rep(NA, maxn)
cabs <- rep(NA, maxn)
xabs <- rep(NA, maxn)
nrel <- rep(NA, maxn)
frel <- rep(NA, maxn)
crel <- rep(NA, maxn)
xrel <- rep(NA, maxn)

mult <- 2
trep <- 1000L

for (ni in 1:maxn) {
  nn <- mult * ni # number of elements
  xx <- rep(pi / 2, nn) # Choose pi/2 to avoid integer numbers
  ## cat(nn, "\n")
  ga <- genrose.g(xx, gs = 100.0)
  gn <- grad(genrose.f, xx, gs = 100.0)
  gf <- fwgapp(genrose.f, xx, gs = 100.0)
  gc <- centgapp(genrose.f, xx, gs = 100.0)
  gx <- grad(genrose.f, xx, method = "complex", gs = 100.0)
  ntime2 <- system.time(for (i in 1:trep) {
    gn <- grad(genrose.f, xx)
  })[3]
  ctime2 <- system.time(for (i in 1:trep) {
    gc <- centgapp(genrose.f, xx)
  })[3]
  xtime2 <- system.time(for (i in 1:trep) {
    gx <- grad(genrose.f, xx, method = "complex")
  })[3]
  ftime2 <- system.time(for (i in 1:trep) {
    gf <- fwgapp(genrose.f, xx)
  })[3]
  atime2 <- system.time(for (i in 1:trep) {
    ga <- genrose.g(xx)
  })[3]
  tt <- c(ta = atime2, tn = ntime2, tf = ftime2, tx = xtime2, tc = ctime2)
  # print(tt)
  n[ni] <- nn
  atym[ni] <- atime2
  ntym[ni] <- ntime2
  ftym[ni] <- ftime2
  ctym[ni] <- ctime2
  xtym[ni] <- xtime2

  ag[ni] <- vnorm(ga)
  nrat[ni] <- ntime2 / atime2
  frat[ni] <- ftime2 / atime2
  crat[ni] <- ctime2 / atime2
  xrat[ni] <- xtime2 / atime2

  nabs[ni] <- max(abs(gn - ga))
  fabs[ni] <- max(abs(gf - ga))
  cabs[ni] <- max(abs(gc - ga))
  xabs[ni] <- max(abs(gx - ga))

  nrel[ni] <- nabs[ni] / max(abs(ga))
  frel[ni] <- fabs[ni] / max(abs(ga))
  crel[ni] <- cabs[ni] / max(abs(ga))
  xrel[ni] <- xabs[ni] / max(abs(ga))
  ##    tmp<-readline("next")
}
derans <- data.frame(
  n, atym, ntym, ftym, ctym, xtym,
  nrat, frat, crat, xrat, nabs, ag, fabs, cabs, xabs, nrel, frel, crel, xrel
)
```

```{r}
# library(dtime)
## ----label=C10derivtab3, cache=TRUE, echo=FALSE, fig.height=6.5----------
dtime <- data.frame(derans$n, derans$atym, derans$ntym, derans$ftym, derans$ctym, derans$xtym)
leg.txt <- c("analytic", "numDeriv", "forward", "central", "complexstep")
names(dtime) <- c("np", leg.txt)
attach(dtime)
plot(np, numDeriv, xlab = "npar", ylab = "time", pch = 1, ylim = c(0, 7.5))
points(np, complexstep, pch = 3)
points(np, analytic, pch = 20)
points(np, forward, pch = 4)
points(np, central, pch = 2)
title(main = "Seconds for 1000 executions of approximations")
title(sub = "Genrose function")
y.leg <- c(5.5, 5, 4.5, 4, 3.5)
for (i in 1:5) {
  legend(1.2, y.leg[i], leg.txt[i], pch = c(20, 1, 4, 2, 3)[i], box.lwd = NA)
}
detach(dtime)
```

```{r}
## ----label=C10derivtab4, cache=TRUE, echo=FALSE--------------------------
drelerr <- data.frame(derans$n, derans$frel, derans$crel, derans$nrel, derans$xrel)
leg.txt <- c("forward", "central", "numDeriv", "complexstep")
names(drelerr) <- c("npar", leg.txt)
drelerr
# pander::pandoc.table(signif(drelerr,3))
```
